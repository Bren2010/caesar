<!DOCTYPE html>

<html>
<head>
  <title>ots.coffee</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="caesar.html">
                caesar.coffee
              </a>
            
              
              <a class="source" href="commitment.html">
                commitment.coffee
              </a>
            
              
              <a class="source" href="format.html">
                format.coffee
              </a>
            
              
              <a class="source" href="hash.html">
                hash.coffee
              </a>
            
              
              <a class="source" href="key.html">
                key.coffee
              </a>
            
              
              <a class="source" href="kts.html">
                kts.coffee
              </a>
            
              
              <a class="source" href="message.html">
                message.coffee
              </a>
            
              
              <a class="source" href="opse.html">
                opse.coffee
              </a>
            
              
              <a class="source" href="ots.html">
                ots.coffee
              </a>
            
              
              <a class="source" href="searchable.html">
                searchable.coffee
              </a>
            
              
              <a class="source" href="tree.html">
                tree.coffee
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>ots.coffee</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>One-Time Signature schemes are digital signature mechanisms where each<br>keypair can be used at most once.  They have a much lower signing and 
verification cost than traditional signatures, making them ideal for 
authenticating broadcast streams.  Use at your own discretion.</p>
<p>Implemented here is HORS.  Data of any length may be signed.</p>
<p><a href="https://eprint.iacr.org/2002/014.pdf">https://eprint.iacr.org/2002/014.pdf</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>crypto = <span class="hljs-built_in">require</span> <span class="hljs-string">'crypto'</span>
stream = <span class="hljs-built_in">require</span> <span class="hljs-string">'stream'</span>
hash = <span class="hljs-built_in">require</span> <span class="hljs-string">'./hash'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Create a random key for a one-time signature.  Outputs a random keypair in 
the form of [public key, private key].  It’s best not to change any of the 
arguments if you don’t know what they do.</p>
<ol>
<li><code>l</code> is the length (in bytes) of the random strings generated.</li>
<li><code>k</code> is the number of random objects to pull from the private key.  (2 | k)</li>
<li><code>t</code> is the number of random strings to generate.  (t | 2^32)</li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.<span class="hljs-function"><span class="hljs-title">generateKey</span> = <span class="hljs-params">(l = <span class="hljs-number">10</span>, k = <span class="hljs-number">20</span>, t = <span class="hljs-number">256</span>)</span> -&gt;</span>
    [s, v] = [[], []]
    
    s.push crypto.randomBytes(l) <span class="hljs-keyword">until</span> s.length <span class="hljs-keyword">is</span> t
    v[i] = hash.chain(si, <span class="hljs-number">1</span>, <span class="hljs-string">'sha1'</span>).slice(<span class="hljs-number">0</span>, l) <span class="hljs-keyword">for</span> si, i <span class="hljs-keyword">in</span> s
    
    [[k, v], [k, s]]</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Class for generating one-time signatures.  Sign objects are writable streams.
The data written is used to generate the signature.  Once all of the data has 
been written, the <code>sign</code> method will return the signature.  It’s best not to 
change any of the arguments if you don’t know what they do.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Sign</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">stream</span>.<span class="hljs-title">Writable</span></span>
    <span class="hljs-attribute">constructor</span>:<span class="hljs-function"> -&gt;</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> exports.Sign <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> exports.Sign()
        stream.Writable.call <span class="hljs-keyword">this</span>
        
        <span class="hljs-property">@hash</span> = crypto.createHash <span class="hljs-string">'sha1'</span>
    
    <span class="hljs-attribute">_write</span>: <span class="hljs-function"><span class="hljs-params">(chunk, encoding, cb)</span> -&gt;</span> <span class="hljs-property">@hash</span>.write chunk, encoding, cb</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Calculates the signature on all the updated data passed through the sign.</p>
<ol>
<li><code>privKey</code> is the private key to sign with.</li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-attribute">sign</span>: <span class="hljs-function"><span class="hljs-params">(privKey)</span> -&gt;</span>
        <span class="hljs-property">@hash</span>.end()
        out = <span class="hljs-property">@hash</span>.read()
        
        [j, sig] = [<span class="hljs-number">0</span>, []]
        
        <span class="hljs-keyword">until</span> j <span class="hljs-keyword">is</span> privKey[<span class="hljs-number">0</span>]
            n = out.readUInt8(j) % privKey[<span class="hljs-number">1</span>].length
            sig.push privKey[<span class="hljs-number">1</span>][n]
            
            ++j
        
        sig</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Class for verifying one-time signatures.  Verify objects are writable streams.
The data written is used to verify the signature.  Once all of the data has 
been written, the <code>verify</code> method will return true if the supplied signature 
is valid.  It’s best not to change any of the arguments if you don’t know what 
they do.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Verify</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">stream</span>.<span class="hljs-title">Writable</span></span>
    <span class="hljs-attribute">constructor</span>:<span class="hljs-function"> -&gt;</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> exports.Verify <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> exports.Verify()
        stream.Writable.call <span class="hljs-keyword">this</span>
        
        <span class="hljs-property">@hash</span> = crypto.createHash <span class="hljs-string">'sha1'</span>
    
    <span class="hljs-attribute">_write</span>: <span class="hljs-function"><span class="hljs-params">(chunk, encoding, cb)</span> -&gt;</span> <span class="hljs-property">@hash</span>.write chunk, encoding, cb</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Verifies the signed data.  Returns true or false depending on validity.</p>
<ol>
<li><code>pubKey</code> is the public key to verify with.</li>
<li><code>signature</code> is the candidate signature.</li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-attribute">verify</span>: <span class="hljs-function"><span class="hljs-params">(pubKey, sig)</span> -&gt;</span>
        <span class="hljs-property">@hash</span>.end()
        out = <span class="hljs-property">@hash</span>.read()
        
        [j, i] = [<span class="hljs-number">0</span>, []]
        
        <span class="hljs-keyword">until</span> j <span class="hljs-keyword">is</span> pubKey[<span class="hljs-number">0</span>]
            n = out.readUInt8(j) % pubKey[<span class="hljs-number">1</span>].length
            
            cand = hash.chain(sig[j], <span class="hljs-number">1</span>, <span class="hljs-string">'sha1'</span>).slice(<span class="hljs-number">0</span>, pubKey[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>].length)
            <span class="hljs-keyword">if</span> cand.toString(<span class="hljs-string">'hex'</span>) <span class="hljs-keyword">isnt</span> pubKey[<span class="hljs-number">1</span>][n].toString(<span class="hljs-string">'hex'</span>)
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
            
            ++j
        
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
