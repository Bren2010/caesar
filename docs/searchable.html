<!DOCTYPE html>

<html>
<head>
  <title>searchable.coffee</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="caesar.html">
                caesar.coffee
              </a>
            
              
              <a class="source" href="format.html">
                format.coffee
              </a>
            
              
              <a class="source" href="hash.html">
                hash.coffee
              </a>
            
              
              <a class="source" href="key.html">
                key.coffee
              </a>
            
              
              <a class="source" href="message.html">
                message.coffee
              </a>
            
              
              <a class="source" href="searchable.html">
                searchable.coffee
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>searchable.coffee</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>crypto = require <span class="string">'crypto'</span>
stream = require <span class="string">'stream'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Largely a passthrough stream.  It won&#39;t change the data, but it will do some 
trivial index generation and keep track of the size of the data passed to it.
Access Indexer.index to get the properly formed index for the given data, and
Indexer.size for the size in bytes of the given data.</p>
<ol>
<li><code>id</code> is the id of the document being indexed.  Document ids should have no
publicly discernable relationship to the document.  Random ids are
recommended (but not required).  Auto generated ids like from Twitter&#39;s 
Snowflake or RethinkDB are fine to use.  <em>(Object)</em></li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="class"><span class="keyword">class</span> <span class="title">exports</span>.<span class="title">Indexer</span> <span class="keyword">extends</span> <span class="title">stream</span>.<span class="title">Transform</span></span>
    constructor: (<span class="property">@id</span>) -&gt;
        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">this</span> <span class="keyword">instanceof</span> exports.Indexer
            <span class="keyword">return</span> <span class="keyword">new</span> exports.Indexer <span class="property">@id</span>
        
        stream.Transform.call <span class="keyword">this</span>, decodeStrings: <span class="literal">true</span>
        [<span class="property">@index</span>, <span class="property">@leftover</span>, <span class="property">@size</span>] = [{}, <span class="string">''</span>, <span class="number">0</span>]
    
    _clean: (word) -&gt; word.toLowerCase().replace <span class="regexp">/[^a-z0-9]/g</span>, <span class="string">''</span>
    _push: (data) -&gt;
        data[i] = <span class="property">@_clean</span> word <span class="keyword">for</span> i, word <span class="keyword">of</span> data
        <span class="property">@index</span>[word] = <span class="property">@id</span> <span class="keyword">for</span> word <span class="keyword">in</span> data
        
        <span class="keyword">delete</span> <span class="property">@index</span>[<span class="string">''</span>]
    
    _transform: (chunk, encoding, done) -&gt;
        data = (<span class="property">@leftover</span> + chunk.toString()).split <span class="regexp">/[\s]/g</span>
        <span class="property">@leftover</span> = data.splice(data.length - <span class="number">1</span>, <span class="number">1</span>)?[<span class="number">0</span>]
        <span class="property">@_push</span> data
        <span class="property">@size</span> += chunk.length
        
        <span class="property">@push</span> chunk
        done()
    
    _flush: (done) -&gt;
        <span class="keyword">if</span> <span class="property">@leftover</span>.length <span class="keyword">is</span> <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">return</span> done()
        <span class="property">@_push</span> [<span class="property">@leftover</span>]
        <span class="property">@push</span> <span class="literal">null</span>
        done()</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Utility class for a secure search server.</p>
<ol>
<li><code>index</code> is the secure index to initialize the server.  Use {} if none.  To
persist the secure index, before the application is shut down access
Server.index and save the object in a persistent data store.  <em>(Object)</em></li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="class"><span class="keyword">class</span> <span class="title">exports</span>.<span class="title">Server</span></span>
    constructor: (<span class="property">@index</span>) -&gt;
        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">this</span> <span class="keyword">instanceof</span> exports.Server
            <span class="keyword">return</span> <span class="keyword">new</span> exports.Server <span class="property">@index</span></pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Takes a secure query and returns an array of matching document ids.</p>
<ol>
<li><code>query</code> a secure query generated by the client.  <em>(Object)</em></li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>    search: (query) -&gt;
        out = []
        <span class="keyword">for</span> dn, trpdrs <span class="keyword">of</span> query
            <span class="keyword">if</span> <span class="keyword">not</span> <span class="property">@index</span>[dn]? <span class="keyword">then</span> <span class="keyword">return</span>
            domain = <span class="property">@index</span>[dn].index
            
            <span class="function"><span class="title">good</span></span> = (id) -&gt; id? <span class="keyword">and</span> -<span class="number">1</span> <span class="keyword">is</span> out.indexOf id
            out.push domain[trpdr] <span class="keyword">for</span> trpdr <span class="keyword">in</span> trpdrs <span class="keyword">when</span> good domain[trpdr]
        
        out</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Attempts to update the secure index.  Will either return true, indicating
that the update was successful or a merge request telling the client to 
merge it&#39;s current index with the given index and retry.</p>
<ol>
<li><code>domain</code> is the index domain name.  Domain names should have no
publicly discernable relationship to the data under them.  It is
recommended (but not required) that they be random.  <em>(String)</em></li>
<li><code>index</code> the new secure index supplied by the client.  <em>(Object)</em></li>
<li><code>reps</code> is the list old domains that this new request will replace.
<em>(Array)</em></li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>    update: (domain, index, reps = []) -&gt;
        <span class="keyword">for</span> dn, cand <span class="keyword">of</span> <span class="property">@index</span>
            <span class="keyword">if</span> cand.docs.length &lt;= index.docs.length <span class="keyword">and</span> reps.indexOf(dn) <span class="keyword">is</span> -<span class="number">1</span>
                <span class="keyword">return</span> [dn, cand.docs]
        
        <span class="keyword">delete</span> <span class="property">@index</span>[dn] <span class="keyword">for</span> dn <span class="keyword">in</span> reps
        <span class="property">@index</span>[domain] = index
        
        <span class="literal">true</span></pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Utility class for a secure search client.</p>
<ol>
<li><code>keys</code> is the keyring used to maintain the secure index.  Use {} if none.
To persist the key ring, before the application is shut down access
Client.keys and save the object in a persistent data store.  <em>(Object)</em></li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="class"><span class="keyword">class</span> <span class="title">exports</span>.<span class="title">Client</span></span>
    constructor: (<span class="property">@keys</span>) -&gt;
        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">this</span> <span class="keyword">instanceof</span> exports.Client
            <span class="keyword">return</span> <span class="keyword">new</span> exports.Client <span class="property">@keys</span></pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Deletes the information on domains that have been outdated.</p>
<ol>
<li><code>dn</code> is a domain name to delete.  <em>(String)</em></li>
<li>...</li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>    outdate: (dns...) -&gt; <span class="keyword">delete</span> <span class="property">@keys</span>[dn] <span class="keyword">for</span> dn <span class="keyword">in</span> dns</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Creates a secure query on a given word.</p>
<ol>
<li><code>word</code> the word to generate the query on.  <em>(String)</em></li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>    createQuery: (word) -&gt;
        word = word.substr <span class="number">0</span>, <span class="number">28</span>
        offset = <span class="number">28</span> - word.length
        
        out = {}
        <span class="keyword">for</span> dn, key <span class="keyword">of</span> <span class="property">@keys</span>
            out[dn] = []
            i = <span class="number">0</span>
            
            <span class="keyword">until</span> i <span class="keyword">is</span> key[<span class="number">0</span>]
                buff = <span class="keyword">new</span> Buffer <span class="number">32</span>
                buff.fill <span class="number">0</span>
                buff.writeUInt32BE i, <span class="number">28</span>
                buff.write word, offset, word.length
                
                hash = crypto.createHash <span class="string">'sha256'</span>
                hash.end buff
                sum = hash.read()
                
                cipher = crypto.createCipher <span class="string">'aes-256-cbc'</span>, key[<span class="number">1</span>]
                cipher.end sum
                
                k = cipher.read().toString <span class="string">'base64'</span>
                out[dn].push k
                ++i
        
        out</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Creates a secure index.</p>
<ol>
<li><code>domain</code> is the domain name of the index.  See Server.update for more
information on domain names.  <em>(String)</em></li>
<li><code>max</code> is the size in bytes of the largest document included in the
given index.  <em>(Number)</em></li>
<li><code>index</code> is an index to secure.  (From Indexer or the like).  <em>(Object)</em></li>
<li>...</li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>    secureIndex: (domain, max, indexes...) -&gt;
        key = crypto.randomBytes <span class="number">32</span>
        index = {} <span class="comment"># Merge indexes.</span>
        
        <span class="keyword">for</span> list <span class="keyword">in</span> indexes
            index[word].push id <span class="keyword">for</span> word, id <span class="keyword">of</span> list <span class="keyword">when</span> index[word]?
            index[word] = [id] <span class="keyword">for</span> word, id <span class="keyword">of</span> list <span class="keyword">when</span> <span class="keyword">not</span> index[word]?
        
        sindex = {} <span class="comment"># Secure index</span>
        <span class="keyword">for</span> word, ids <span class="keyword">of</span> index
            word = word.substr <span class="number">0</span>, <span class="number">28</span>
            offset = <span class="number">28</span> - word.length
            
            <span class="keyword">for</span> n, id <span class="keyword">of</span> ids
                buff = <span class="keyword">new</span> Buffer <span class="number">32</span>
                buff.fill <span class="number">0</span>
                buff.writeUInt32BE n, <span class="number">28</span>
                buff.write word, offset, word.length
                
                hash = crypto.createHash <span class="string">'sha256'</span>
                hash.end buff
                sum = hash.read()
                
                cipher = crypto.createCipher <span class="string">'aes-256-cbc'</span>, key
                cipher.end sum
                
                k = cipher.read().toString <span class="string">'base64'</span>
                sindex[k] = id
        
        words = Object.keys index <span class="comment"># Get an array of the unique words.</span>
        docs = [] <span class="comment"># Get an array of unique document ids</span>
        <span class="keyword">for</span> word, ids <span class="keyword">of</span> index
            docs.push id <span class="keyword">for</span> id <span class="keyword">in</span> ids <span class="keyword">when</span> -<span class="number">1</span> <span class="keyword">is</span> docs.indexOf id
        
        <span class="property">@keys</span>[domain] = [docs.length, key] <span class="comment"># Key management.</span>
        
        one = [<span class="number">256</span>, <span class="number">131072</span>, <span class="number">50331648</span>] <span class="comment"># Pad the secure index.</span>
        two = [<span class="number">256</span>, <span class="number">65536</span>, <span class="number">16777216</span>]
        [threshold, sum, i] = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]
        
        <span class="keyword">while</span> threshold &lt;= max
            threshold += one[i]
            sum += two[i]
            ++i
        
        threshold = threshold - one[i - <span class="number">1</span>]
        sum = sum - two[i - <span class="number">1</span>]
        sum += Math.floor((max - threshold) / i)
        
        docs = [] <span class="comment"># Get an array of unique document ids</span>
        <span class="keyword">for</span> word, ids <span class="keyword">of</span> index
            docs.push id <span class="keyword">for</span> id <span class="keyword">in</span> ids <span class="keyword">when</span> -<span class="number">1</span> <span class="keyword">is</span> docs.indexOf id
        
        <span class="keyword">for</span> id <span class="keyword">in</span> docs
            c = <span class="number">0</span> <span class="comment"># Number of entries in the index that already contain id.</span>
            ++c <span class="keyword">for</span> entry <span class="keyword">in</span> sindex <span class="keyword">when</span> entry <span class="keyword">is</span> id
            
            l = sum - c
            <span class="keyword">while</span> l -= <span class="number">1</span>
                buff = <span class="keyword">new</span> Buffer <span class="number">32</span>
                buff.fill <span class="number">0</span>
                buff.writeUInt32BE docs.length + l, <span class="number">28</span>
                
                hash = crypto.createHash <span class="string">'sha256'</span>
                hash.end buff
                sum = hash.read()
                
                cipher = crypto.createCipher <span class="string">'aes-256-cbc'</span>, key
                cipher.end sum
                
                k = cipher.read().toString <span class="string">'base64'</span>
                sindex[k] = id
        
        <span class="function"><span class="title">shuffle</span></span> = (array) -&gt;
            i = array.length
            <span class="keyword">if</span> i <span class="keyword">is</span> <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">false</span>
            
            bytes = Math.ceil(Math.log(array.length) / (<span class="number">8</span> * Math.log(<span class="number">2</span>)))
            <span class="keyword">while</span> i -= <span class="number">1</span>
                j = array.length <span class="comment"># Guess random numbers until one is in range.</span>
                <span class="keyword">until</span> j &lt; array.length
                    a = <span class="keyword">new</span> Buffer <span class="number">4</span> <span class="comment"># Create new blank buffer.</span>
                    a.fill <span class="number">0</span>
                    
                    b = crypto.randomBytes bytes <span class="comment"># Write random 32bit uint.</span>
                    b.copy a
                    
                    j = a.readUInt32LE(<span class="number">0</span>) <span class="comment"># Read as 32bit uint.</span>
                
                [array[j], array[i]] = [array[i], array[j]] <span class="comment"># Swap values.</span>
            
            array
        
        keys = shuffle Object.keys sindex <span class="comment"># Shuffle the secure index.</span>
        rsindex = {}
        rsindex[key] = sindex[key] <span class="keyword">for</span> key <span class="keyword">in</span> keys
        
        docs: docs, index: rsindex</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
