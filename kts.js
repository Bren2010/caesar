// Generated by CoffeeScript 1.7.1
(function() {
  var crypto, hash;

  crypto = require('crypto');

  hash = require('./hash');

  exports.Signer = (function() {
    function Signer(k, privateKey) {
      var head, i, vi, _ref;
      this.heads = [];
      if (privateKey != null) {
        this.heads.push(privateKey);
      } else {
        this.heads.push(crypto.randomBytes(20).toString('hex'));
      }
      while (this.heads.length !== (k + 2)) {
        _ref = [this.heads[this.heads.length - 1], ''], vi = _ref[0], head = _ref[1];
        i = 0;
        while (i !== 20) {
          head += hash.chain(vi + 's' + (i + 1), 256, 'sha1');
          ++i;
        }
        i = 0;
        while (i !== 2) {
          head += hash.chain(vi + 'c' + (i + 1), 256, 'sha1');
          ++i;
        }
        head = hash.chain(head, 1, 'sha1');
        this.heads.push(head);
      }
    }

    Signer.prototype.getPublicKey = function() {
      return this.heads[this.heads.length - 1];
    };

    Signer.prototype.getPrivateKey = function() {
      return [this.heads.length - 2, this.heads[0]];
    };

    Signer.prototype.sign = function(msg) {
      var checksum, h, i, n, serial, sig, vi;
      if (this.heads[this.heads.length - 3] == null) {
        return false;
      }
      checksum = 0;
      h = hash.chain(msg, 1, 'sha1');
      sig = [];
      i = 0;
      while (i !== h.length) {
        n = parseInt(h[i] + h[i + 1], 16) + 1;
        serial = (i / 2) + 1;
        vi = hash.chain(this.heads[this.heads.length - 3] + 's' + serial, n, 'sha1');
        sig.push(vi);
        checksum += n;
        i = i + 2;
      }
      i = 0;
      checksum = ('00' + ((256 * 20) - checksum).toString(16)).substr(-3);
      while (i !== 2) {
        n = parseInt(checksum[i], 16) + 1;
        vi = hash.chain(this.heads[this.heads.length - 3] + 'c' + (i + 1), n, 'sha1');
        sig.push(vi);
        ++i;
      }
      this.heads.pop();
      return sig;
    };

    return Signer;

  })();

  exports.Verifier = (function() {
    function Verifier(publicKey) {
      this.publicKey = publicKey;
    }

    Verifier.prototype.forward = function(msg, sig) {
      var candFinal, candPubKey, checksum, h, i, n;
      h = hash.chain(msg, 1, 'sha1');
      candPubKey = '';
      checksum = 0;
      i = 0;
      while (i !== h.length) {
        n = parseInt(h[i] + h[i + 1], 16) + 1;
        candPubKey += hash.chain(sig[i / 2], 256 - n, 'sha1');
        checksum += n;
        i = i + 2;
      }
      i = 0;
      checksum = ('00' + ((256 * 20) - checksum).toString(16)).substr(-3);
      while (i !== 2) {
        n = parseInt(checksum[i], 16) + 1;
        candPubKey += hash.chain(sig[i + 20], 256 - n, 'sha1');
        ++i;
      }
      candPubKey = hash.chain(candPubKey, 1, 'sha1');
      candFinal = '';
      i = 0;
      while (i !== 20) {
        candFinal += hash.chain(candPubKey + 's' + (i + 1), 256, 'sha1');
        ++i;
      }
      i = 0;
      while (i !== 2) {
        candFinal += hash.chain(candPubKey + 'c' + (i + 1), 256, 'sha1');
        ++i;
      }
      candFinal = hash.chain(candFinal, 1, 'sha1');
      return [candPubKey, candFinal];
    };

    Verifier.prototype.verify = function(msg, sig) {
      var candFinal, candPubKey, _ref;
      _ref = this.forward(msg, sig), candPubKey = _ref[0], candFinal = _ref[1];
      if (candFinal === this.publicKey) {
        this.publicKey = candPubKey;
        return true;
      } else {
        return false;
      }
    };

    return Verifier;

  })();

}).call(this);
